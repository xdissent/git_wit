{"name":"GitWit","tagline":"Dead simple Git hosting for Rails apps.","body":"[![Build Status](https://travis-ci.org/xdissent/git_wit.png?branch=master)](https://travis-ci.org/xdissent/git_wit)\r\n[![Gem Version](https://badge.fury.io/rb/git_wit.png)](http://badge.fury.io/rb/git_wit)\r\n\r\n## Crash Course\r\n\r\nStart hosting git repositories in seconds. Create a new Rails app and \r\ninstall GitWit:\r\n\r\n```console\r\n$ rails new example --skip-bundle; cd example       # New Rails app\r\n$ echo 'gem \"git_wit\"' >> Gemfile; bundle           # Install git_wit gem\r\n$ rails g git_wit:install insecure_auth insecure_write authenticate authorize_read authorize_write\r\n$ rails s -d  # <- Start Rails server               # ^- Install/config GitWit\r\n```\r\n\r\nThat's it - your app is hosting git repositories. Create a repositories folder,\r\ninit a bare repo, and push to it:\r\n\r\n```console\r\n$ git init; git add .; git commit -m \"That was easy\"\r\n$ mkdir repositories                                # Hosted repos folder\r\n$ git init --bare repositories/example.git          # Example bare repo\r\n$ git remote add origin http://localhost:3000/example.git\r\n$ git push origin master  # Push example app to itself to store in itself!\r\n```\r\n\r\nHTTPS? That works too:\r\n\r\n```console\r\n$ sudo echo \"pre-loading sudo so we can background tunnels in a moment\"\r\n$ rails g git_wit:install authenticate authorize_read authorize_write -f\r\n$ echo 'gem \"tunnels\"' >> Gemfile; bundle\r\n$ sudo tunnels 443 3000 &       # or `rvmsudo tunnels...` if using RVM\r\n$ git remote add https https://localhost/example.git\r\n$ GIT_SSL_NO_VERIFY=1 git push https master:https-master  # Trust yourself\r\n```\r\n\r\nStill not impressed? Try SSH:\r\n\r\n```console\r\n$ rails g git_wit:install authenticate authorize_read authorize_write ssh_user:git_wit -f\r\n$ rails g git_wit:ssh_user      # Creates/configs git_wit SSH user\r\n$ rake git_wit:ssh:add_key      # Grant access for ~/.ssh/id_rsa.pub\r\n$ git remote add ssh git_wit@localhost:example.git\r\n$ git push ssh master:ssh-master\r\n```\r\n\r\nYou might want to get rid of that system user you just created:\r\n\r\n```console\r\n$ rails d git_wit:ssh_user\r\n```\r\n\r\n\r\n## Overview\r\n\r\nGitWit adds git hosting abilities to any Rails app. It provides configurable\r\nauthentication and authorization methods that can be integrated with any \r\nuser/repository access model you'd like. All configuration is handled through a\r\nsingle initializer, \r\n[`config/initializers/git_wit.rb`](https://github.com/xdissent/git_wit/blob/master/lib/generators/git_wit/templates/git_wit.rb). \r\nRun `rails g git_wit:install` to generate a default configuration for \r\nmodification. All configuration details are contained within comments inside\r\nthe initializer, or read on for the highlights.\r\n\r\n\r\n## Authentication\r\n\r\nNormally GitWit prevents the user from sending authentication credentials in\r\nplaintext (via HTTP without SSL). To disable these protections, something you'd \r\n**never** do in a production environment, change the following config values \r\nin the initializer:\r\n\r\n```ruby\r\nconfig.insecure_auth = true\r\nconfig.insecure_write = true\r\n```\r\n\r\nAuthentication is handled by the `config.authenticate` attribute. A valid\r\nauthenticator is any callable that accepts a user model instance and a \r\nclear-text password. The authenticator should return a boolean response \r\nindicating whether the user is authenticated for the given password. To allow\r\nany user as long as the password matches the username:\r\n\r\n```ruby\r\nconfig.authenticate = ->(user, password) do\r\n  user == password\r\nend\r\n```\r\n\r\nThe user model is simply the username as a string by default. Before passing\r\nthe user to the authenticator, GitWit will call `config.user_for_authenication`,\r\npassing it the username and expecting a new user model instance in return. For\r\nexample:\r\n\r\n```ruby\r\nconfig.user_for_authentication = ->(username) do\r\n  User.active.find_by_login username: username\r\nend\r\n```\r\n\r\nNow the `config.authenticate` authenticator will recieve the `User` instance:\r\n\r\n```ruby\r\nconfig.authenticate = ->(user, password) do\r\n  user.valid_password? password   # user is a User\r\nend\r\n```\r\n\r\n\r\n## Authorization\r\n\r\nTwo configuration attributes are responsible for authorization: \r\n`config.authorize_read` and `config.authorize_write`. They're passed the user \r\ninstance (already authenticated) and the repository path as a string. The \r\nrepository path is relative to `config.repositories_path` \r\n(`<app root>/repositories` by default). The authorizers should return a boolean\r\nto grant or deny access accordingly. A simple example:\r\n\r\n```ruby\r\nconfig.authorize_read = ->(user, repository) do\r\n  %w(reader writer).include?(user)\r\nend\r\n\r\nconfig.authorize_write = ->(user, repository) do\r\n  user == \"writer\"\r\nend\r\n```\r\n\r\n\r\n## A quick note about \"local requests\"\r\n\r\nThe default Rails development environment has a config value called \r\n`consider_all_requests_local`, which is `true`. This prevents GitWit from \r\ncorrectly handling authentication responses in some cases. It's not a big deal,\r\nyou'll just be asked to re-authenticate more often and some responses will be\r\nslightly misleading. But the alternative solution, which is to set \r\n`consider_all_requests_local` to `false`, disables any special Rails error \r\nhandling - quite a bummer for development. It would be nice to sort this out a\r\nlittle better in the future. Note that the production environment uses `false`\r\nby default and handles errors appropriately.\r\n\r\n\r\n## Advanced Usage (Devise, Cancan, etc.)\r\n\r\nSee [`test/dummy`](https://github.com/xdissent/git_wit/tree/master/test/dummy) \r\nfor an example app that integrates \r\n[Devise](https://github.com/plataformatec/devise), \r\n[Cancan](https://github.com/ryanb/cancan), \r\n[rolify](https://github.com/EppO/rolify) and\r\n[twitter-bootstrap-rails](https://github.com/seyhunak/twitter-bootstrap-rails). \r\nExample controllers for managing repositories and public keys are included.\r\n\r\n\r\n## SSH support - AKA: The hard part\r\n\r\nTo enable git operations over SSH, you **must have a dedicated SSH user**. This\r\nuser will *only* be used for SSH authentication. Immediately after successfully\r\nauthenticating, the SSH user will `sudo` to the application user to continue\r\nwith the git operation. This eliminates the need for all the bat-shit crazy git\r\npulls/pushes and SSH wrappers and crap that are typical of gitolite/gitosis\r\nsetups. Your application user owns everything except the `authorized_keys` file\r\nand the `ssh_user` only needs to know how to call the `git_wit git-shell` \r\ncommand.\r\n\r\nGitWit comes with an initializer to set everything up for you. First, enable the \r\n`ssh_user` config in `config/initializers/git_wit.rb`:\r\n\r\n```ruby\r\nconfig.ssh_user = \"git_wit\"\r\n```\r\n\r\nNow run the initializer:\r\n\r\n```console\r\n$ rails g git_wit:ssh_user\r\n```\r\n\r\nTo add a public key: `rake git_wit:ssh:add_key`\r\n\r\nSomething not working? `rake git_wit:ssh:debug`\r\n\r\n\r\n## Git hooks and configs and umasks and everything\r\n\r\nDude, your app owns the repos now. Hooks are just files again! Rediscover the\r\n[grit](https://github.com/mojombo/grit) gem and go nuts with all kinds of fun\r\nstuff that used to be a serious pain. Paranoid? Lock down the permissions on\r\nyour repositories folder so that only your application user can read it. The\r\nSSH shell will still be executed as the application user so it's no sweat.\r\n\r\n\r\nThis project rocks and uses MIT-LICENSE.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}