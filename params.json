{"name":"GitWit","tagline":"Dead simple Git hosting for Rails apps.","body":"[![Build Status](https://travis-ci.org/xdissent/git_wit.png?branch=master)](https://travis-ci.org/xdissent/git_wit)\r\n[![Gem Version](https://badge.fury.io/rb/git_wit.png)](http://badge.fury.io/rb/git_wit)\r\n\r\n## Quickstart\r\n\r\nCreate a Rails 3.2 app if you don't already have one. Add `git_wit` to your\r\nGemfile:\r\n\r\n```ruby\r\n# Use github for now - early development:\r\ngem \"git_wit\", git: \"https://github.com/xdissent/git_wit.git\"\r\n\r\n# Later it might be safe to use a rubygems release:\r\n# gem \"git_wit\", \"~> 0.1.0\"\r\n```\r\n\r\nRun `bundle install` followed by `rails g git_wit:install` and then checkout \r\n[`config/initializers/git_wit.rb`](https://github.com/xdissent/git_wit/blob/master/lib/generators/git_wit/templates/git_wit.rb). \r\nYou'll want to first change `config.repositories_path` to a folder where you'd \r\nlike to store your repositories. Let's use \"tmp/repositories\" in our app root \r\nfor fun:\r\n\r\n```ruby\r\nconfig.repositories_path = Rails.root.join(\"tmp\", \"repositories\").to_s\r\n```\r\n\r\nNormally you wouldn't want to allow users to send their authentication \r\ncredentials over an insecure protocol like HTTP, because they'll be sent in \r\nplain text over the wire. And since anonymous write access is always disallowed,\r\nthat means you can't safely push over HTTP without SSL. To disable these \r\nprotections, something you'd **never** do in a production environment, change\r\nthe following config values in the initializer:\r\n\r\n```\r\nconfig.insecure_auth = true\r\nconfig.insecure_write = true\r\n```\r\n\r\nNow let's set up some simple (fake) authentication and authorization:\r\n\r\n```ruby\r\nconfig.authenticate = ->(user, password) do\r\n  %w(reader writer).include?(user) && user == password\r\nend\r\n\r\nconfig.authorize_read = ->(user, repository) do\r\n  %w(reader writer).include?(user)\r\nend\r\n\r\nconfig.authorize_write = ->(user, repository) do\r\n  user == \"writer\"\r\nend\r\n```\r\n\r\nWhat we've done is effectively create two users: `reader` and `writer`. Both can\r\nread all repositories, but only `writer` may write (and can write to any repo.)\r\nBoth users are considered authenticated if the password matches the username.\r\n\r\nNow your app is ready to start serving git repos over HTTP. Just create the \r\nrepositories folder, initialize a repo and start the server:\r\n\r\n```console\r\n$ mkdir -p tmp/repositories\r\n$ git init --bare tmp/repositories/example.git\r\n$ rails s\r\n```\r\n\r\nClone your repo, make some changes, and push:\r\n\r\n```console\r\n$ git clone http://localhost:3000/example.git\r\n$ cd example\r\n$ touch README\r\n$ git add README\r\n$ git commit -m \"First\"\r\n$ git push origin master\r\n```\r\n\r\nYour server will ask you for a username and password when you push - use \r\n`writer` for both and it should accept your changes.\r\n\r\n\r\n## SSL\r\n\r\nYou **really** should turn `insecure_auth` and `insecure_write` back to `false`\r\nas quickly as possible and enable SSL for read/write access. GitWit doesn't \r\nneed any special SSL configuration - just flip SSL on in whatever web server\r\nis running Rails. You can also use the \r\n[tunnels](https://github.com/jugyo/tunnels) gem to run your app with SSL in \r\ndevelopment. Just add it to the Gemfile and run `bundle install` followed by\r\n`sudo tunnels` (or `rvmsudo tunnels` for RVM). For `rails s`, which runs on\r\nport 3000 by default, run `sudo tunnels 443 3000`. Now you may clone \r\nrepositories over HTTPS:\r\n\r\n```console\r\n$ git clone https://localhost/example.git\r\n```\r\n\r\n\r\n## A quick note about \"local requests\"\r\n\r\nThe default Rails development environment has a config value called \r\n`consider_all_requests_local`, which is `true`. This prevents GitWit from \r\ncorrectly handling authentication responses in some cases. It's not a big deal,\r\nyou'll just be asked to reauthenticate more often and some responses will be\r\nslightly misleading. But the alternative solution, which is to set \r\n`consider_all_requests_local` to false, disables any special Rails error \r\nhandling - quite a bummer for development. It would be nice to sort this out a\r\nlittle better in the future. Note that the production environment uses `false`\r\nby default and handles errors approriately.\r\n\r\n\r\n## Advanced Usage (Devise, Cancan, etc.)\r\n\r\nSee [`test/dummy`](https://github.com/xdissent/git_wit/tree/master/test/dummy) \r\nfor an example app that integrates \r\n[Devise](https://github.com/plataformatec/devise), \r\n[Cancan](https://github.com/ryanb/cancan), \r\n[rolify](https://github.com/EppO/rolify) and\r\n[twitter-bootstrap-rails](https://github.com/seyhunak/twitter-bootstrap-rails). \r\nExample controllers for managing repositories and public keys are included.\r\n\r\n\r\n## SSH support - AKA: The hard part\r\n\r\nTo enable git operations over SSH, you **must have a dedicated SSH user**. This\r\nuser will *only* be used for SSH autentication. Immediately after successfully\r\nauthenticating, the SSH user will `sudo` to the application user to continue\r\nwith the git operation. This eliminates the need for all the bat-shit crazy git\r\npulls/pushes and SSH wrappers and crap that are typical of gitolite/gitosis\r\nsetups. Your application user owns everything except the `authorized_keys` file\r\nand the `ssh_user` only needs to know how to call the `gw-shell` command.\r\n\r\nFirst, create a dedicated SSH user. On Mountain Lion:\r\n\r\n```console\r\n$ sudo dscl . -create /Groups/gitwit\r\n$ sudo dscl . -create /Groups/gitwit PrimaryGroupID 333\r\n$ sudo dscl . -create /Groups/gitwit RealName \"GitWit Server\"\r\n$ sudo dscl . -create /Users/gitwit UniqueID 333\r\n$ sudo dscl . -create /Users/gitwit PrimaryGroupID 333\r\n$ sudo dscl . -create /Users/gitwit NFSHomeDirectory /var/gitwit\r\n$ sudo dscl . -create /Users/gitwit UserShell /bin/bash\r\n$ sudo dscl . -create /Users/gitwit RealName \"GitWit Server\"\r\n$ sudo mkdir -p ~gitwit\r\n$ sudo chown -R gitwit:gitwit ~gitwit\r\n```\r\n\r\nEnable the `ssh_user` config value in `config/initializers/git_wit.rb`:\r\n\r\n```ruby\r\nconfig.ssh_user = \"gitwit\"\r\n```\r\n\r\nNow your application user needs to be allowed to `sudo` as `ssh_user` and vice\r\nversa. Edit `/etc/sudoers` using `sudo visudo` and add the following lines:\r\n\r\n```\r\nrails_user ALL=(gitwit) NOPASSWD:ALL\r\ngitwit ALL=(rails_user) NOPASSWD:ALL\r\n```\r\n\r\nReplace `rails_user` with the application under which your Rails app runs, which\r\nwill be your personal username if using `rails s` or Pow.\r\n\r\nTest your `sudo` rights and initialize the `ssh_user` environment:\r\n\r\n```console\r\n$ sudo -u gitwit -i\r\n$ mkdir .ssh\r\n$ chmod 700 .ssh\r\n$ touch .ssh/authorized_keys\r\n$ chmod 600 .ssh/authorized_keys\r\n```\r\n\r\nIf you're using RVM or some other wacky environment manipulating tool, you're \r\ngoing to want to adjust the login environment for `ssh_user` by creating a\r\n`~ssh_user/.bashrc` file. For example, to load a specific RVM gemset:\r\n\r\n```bash\r\nsource \"/Users/xdissent/.rvm/environments/ruby-1.9.3-p385@git_wit\"\r\n```\r\n\r\nYou may also need to adjust the `PATH` to include the location of the `gw-shell`\r\nexecutable. If you're using `bundle --binstubs` for example:\r\n\r\n```bash\r\nexport PATH=\"/path/to/app/bin:$PATH\"\r\n```\r\n\r\nThe `gw-shell` command handles the authentication and authorization for the SSH\r\nprotocol. It is initially called by `ssh_user` upon login (git operation) and it\r\nwill attempt to `sudo` to the application user and re-run itself with the same\r\nenvironment. It determines which user is the \"application user\" by looking at\r\nwho owns the rails app root folder. To determine where the app root is actually\r\nlocated, it looks for the ENV variables `RAILS_ROOT` and `BUNDLE_GEMFILE` in \r\norder. When in doubt, set `RAILS_ROOT` in `~ssh_user/.bashrc`:\r\n\r\n```bash\r\nexport RAILS_ROOT=\"/path/to/app\"\r\n```\r\n\r\n**Remember to add `export RAILS_ENV=\"production\"` for production deployments!**\r\n\r\nYou can easily sanity check your environment using `sudo` as your app user:\r\n\r\n```console\r\n$ sudo -u gitwit -i\r\n$ source .bashrc\r\n$ which gw-shell\r\n/Users/xdissent/Code/git_wit/stubs/gw-shell\r\n$ echo $RAILS_ROOT\r\n/Users/xdissent/Code/git_wit/test/dummy\r\n```\r\n\r\nNow all that's left to do is add some `authorized_keys` and you're all set. \r\nThis can be done from the rails console (`rails c`):\r\n\r\n```ruby\r\nGitWit.add_authorized_key \"writer\", \"ssh-rsa long-ass-key-string writer@example.com\"\r\n# => nil \r\nGitWit.authorized_keys_file.keys\r\n# => [command=\"gw-shell writer\",no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ssh-rsa long-ass-key-string writer@example.com] \r\n```\r\n\r\nYou may now clone/push/pull over SSH - assuming the key you installed for \r\n`writer` is known to your ssh agent (ie `~/.ssh/id_rsa`):\r\n\r\n```console\r\n$ git clone gitwit@localhost:example.git\r\n```\r\n\r\nSee the dummy app in \r\n[`test/dummy`](https://github.com/xdissent/git_wit/tree/master/test/dummy) for \r\na more advanced example of `authorized_keys` management.\r\n\r\n\r\n## Git hooks and configs and umasks and everything\r\n\r\nDude, your app owns the repos now. Hooks are just files again! Rediscover the\r\n[grit](https://github.com/mojombo/grit) gem and go nuts with all kinds of fun\r\nstuff that used to be a serious pain. Paranoid? Lock down the permissions on\r\nyour repositories folder so that only your application user can read it. The\r\nSSH shell will still be executed as the application user so it's no sweat.\r\n\r\n\r\nThis project rocks and uses MIT-LICENSE.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}